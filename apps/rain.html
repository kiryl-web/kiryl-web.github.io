<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RainSurfaceView – HTML Canvas</title>
<style>
  :root {
    --bg-light: #ffffff;
    --bg-dark:  #0f1115;
    --ink: #4281f5;
  }
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
    background: var(--bg-dark);
  }
  body[data-theme="light"] { background: var(--bg-light); }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: none;
  }
  .hud {
    position: fixed;
    left: 12px; bottom: 12px;
    font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif;
    color: #888; user-select: none; opacity: .7;
  }
  body[data-theme="light"] .hud { color: #666; }
</style>
</head>
<body data-theme="dark">
<canvas id="c"></canvas>
<div class="hud">t: theme · click: fullscreen</div>

<script>
(() => {
  'use strict';

  // ----- Config -----
  const COLOR_DROP = '#4281f5';
  const SPEED_MIN = 3;    // keep slower speed
  const SPEED_MAX = 8;
  const MAX_DROPS = 500;

  const SPAWN_BURST_MIN = 1;
  const SPAWN_BURST_MAX = 3;

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  let vw = 0, vh = 0, dpr = 1;
  function resize() {
    dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    vw = Math.floor(window.innerWidth);
    vh = Math.floor(window.innerHeight);
    canvas.width  = vw * dpr;
    canvas.height = vh * dpr;
    canvas.style.width = vw + 'px';
    canvas.style.height = vh + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  const body = document.body;
  function toggleTheme() {
    body.dataset.theme = (body.dataset.theme === 'dark') ? 'light' : 'dark';
  }
  window.addEventListener('keydown', (e) => {
    if (e.key === 't' || e.key === 'T') toggleTheme();
  });

  canvas.addEventListener('click', async () => {
    try {
      if (!document.fullscreenElement) {
        await canvas.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch (_) {}
  });

  class Drop {
    constructor(x, y, speed) {
      this.x = x;
      this.y = y;
      this.speed = speed;
      // --- Bigger drops ---
      this.width = Math.max(2, Math.floor(speed * 0.4));  // wider
      this.height = speed * 3;                            // longer streak
    }
    update() {
      this.y += this.speed;
      return this.y <= vh + this.height;
    }
    draw(ctx) {
      ctx.fillStyle = COLOR_DROP;
      ctx.fillRect(this.x - this.width / 2, this.y - this.height, this.width, this.height);
    }
  }

  const drops = [];

  function spawnIfNeeded() {
    if (drops.length >= MAX_DROPS) return;
    const burst = randInt(SPAWN_BURST_MIN, SPAWN_BURST_MAX);
    for (let i = 0; i < burst && drops.length < MAX_DROPS; i++) {
      const x = randInt(0, vw);
      const speed = randInt(SPEED_MIN, SPEED_MAX);
      drops.push(new Drop(x, 0, speed));
    }
  }

  function clear() {
    ctx.fillStyle = getComputedStyle(document.body)
      .getPropertyValue(body.dataset.theme === 'dark' ? '--bg-dark' : '--bg-light');
    ctx.fillRect(0, 0, vw, vh);
  }

  function step() {
    spawnIfNeeded();
    for (let i = drops.length - 1; i >= 0; i--) {
      if (!drops[i].update()) drops.splice(i, 1);
    }
    clear();
    for (const d of drops) d.draw(ctx);
    requestAnimationFrame(step);
  }

  function randInt(min, maxInclusive) {
    return min + Math.floor(Math.random() * (maxInclusive - min + 1));
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
